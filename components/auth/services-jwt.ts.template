import { SignJWT, jwtVerify, type JWTPayload as JoseJWTPayload } from 'jose';
import { logger } from '@app/utils/logger';
import type { JWTPayload, TokenPair } from '@app/core/types/auth';
import { jwtPayloadSchema } from '@app/core/types/auth';

export class JWTService {
  private readonly accessTokenSecret: Uint8Array;
  private readonly refreshTokenSecret: Uint8Array;
  private readonly accessTokenTTL = '15m';
  private readonly refreshTokenTTL = '7d';

  constructor() {
    const accessSecret = process.env.JWT_ACCESS_SECRET;
    const refreshSecret = process.env.JWT_REFRESH_SECRET;

    if (!accessSecret || !refreshSecret) {
      throw new Error('JWT secrets not configured');
    }

    this.accessTokenSecret = new TextEncoder().encode(accessSecret);
    this.refreshTokenSecret = new TextEncoder().encode(refreshSecret);
  }

  async generateTokenPair(userId: string, email: string): Promise<TokenPair> {
    const [accessToken, refreshToken] = await Promise.all([
      this.generateToken(userId, email, 'access', this.accessTokenSecret, this.accessTokenTTL),
      this.generateToken(userId, email, 'refresh', this.refreshTokenSecret, this.refreshTokenTTL),
    ]);

    return { accessToken, refreshToken };
  }

  private async generateToken(
    userId: string,
    email: string,
    type: 'access' | 'refresh',
    secret: Uint8Array,
    expiresIn: string
  ): Promise<string> {
    const jwt = await new SignJWT({ email, type })
      .setProtectedHeader({ alg: 'HS256' })
      .setSubject(userId)
      .setIssuedAt()
      .setExpirationTime(expiresIn)
      .sign(secret);

    return jwt;
  }

  async verifyAccessToken(token: string): Promise<JWTPayload> {
    return this.verifyToken(token, this.accessTokenSecret, 'access');
  }

  async verifyRefreshToken(token: string): Promise<JWTPayload> {
    return this.verifyToken(token, this.refreshTokenSecret, 'refresh');
  }

  private async verifyToken(
    token: string,
    secret: Uint8Array,
    expectedType: 'access' | 'refresh'
  ): Promise<JWTPayload> {
    try {
      const { payload } = await jwtVerify(token, secret, {
        algorithms: ['HS256'],
      });

      const validatedPayload = jwtPayloadSchema.parse({
        ...payload,
        type: (payload as any).type,
      });

      if (validatedPayload.type !== expectedType) {
        throw new Error(`Invalid token type. Expected ${expectedType}`);
      }

      return validatedPayload;
    } catch (error) {
      logger.error('JWT verification failed', { error });
      throw new Error('Invalid token');
    }
  }

  getExpirationDate(ttl: string): Date {
    const now = new Date();
    const match = ttl.match(/^(\\d+)([mhd])$/);

    if (!match) {
      throw new Error('Invalid TTL format');
    }

    const [, value, unit] = match;
    const amount = parseInt(value, 10);

    switch (unit) {
      case 'm':
        now.setMinutes(now.getMinutes() + amount);
        break;
      case 'h':
        now.setHours(now.getHours() + amount);
        break;
      case 'd':
        now.setDate(now.getDate() + amount);
        break;
    }

    return now;
  }
}
