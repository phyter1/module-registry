import pino from 'pino';
import type { Logger as PinoLogger } from 'pino';

// Logger configuration
const isDevelopment = process.env.NODE_ENV === 'development';
const logLevel = process.env.LOG_LEVEL || (isDevelopment ? 'debug' : 'info');

// Create base logger
const baseLogger = pino({
  level: logLevel,
  ...(isDevelopment && {
    transport: {
      target: 'pino-pretty',
      options: {
        colorize: true,
        ignore: 'pid,hostname',
        translateTime: 'HH:MM:ss',
      },
    },
  }),
  ...(!isDevelopment && {
    timestamp: pino.stdTimeFunctions.isoTime,
    formatters: {
      level: (label) => {
        return { level: label };
      },
    },
  }),
});

// Context storage for request tracing
const contextStorage = new Map<string, any>();

export class Logger {
  private logger: PinoLogger;
  private context: Record<string, any>;

  constructor(context?: Record<string, any>) {
    this.context = context || {};
    this.logger = baseLogger.child(this.context);
  }

  // Create a child logger with additional context
  child(context: Record<string, any>): Logger {
    return new Logger({ ...this.context, ...context });
  }

  // Set request context (for request tracing)
  static setRequestContext(requestId: string, context: Record<string, any>): void {
    contextStorage.set(requestId, context);
  }

  // Get request context
  static getRequestContext(requestId: string): Record<string, any> | undefined {
    return contextStorage.get(requestId);
  }

  // Clear request context
  static clearRequestContext(requestId: string): void {
    contextStorage.delete(requestId);
  }

  // Logging methods
  debug(message: string, meta?: Record<string, any>): void {
    this.logger.debug(meta, message);
  }

  info(message: string, meta?: Record<string, any>): void {
    this.logger.info(meta, message);
  }

  warn(message: string, meta?: Record<string, any>): void {
    this.logger.warn(meta, message);
  }

  error(message: string, error?: Error | unknown, meta?: Record<string, any>): void {
    const errorMeta = error instanceof Error
      ? {
          error: {
            name: error.name,
            message: error.message,
            stack: error.stack,
          },
          ...meta,
        }
      : { error, ...meta };

    this.logger.error(errorMeta, message);
  }

  fatal(message: string, error?: Error | unknown, meta?: Record<string, any>): void {
    const errorMeta = error instanceof Error
      ? {
          error: {
            name: error.name,
            message: error.message,
            stack: error.stack,
          },
          ...meta,
        }
      : { error, ...meta };

    this.logger.fatal(errorMeta, message);
  }

  // Utility methods
  time(label: string): () => void {
    const start = Date.now();
    return () => {
      const duration = Date.now() - start;
      this.info(`${label} completed`, { duration_ms: duration });
    };
  }

  // Flush logs (useful for serverless environments)
  async flush(): Promise<void> {
    return new Promise((resolve) => {
      this.logger.flush(() => {
        resolve();
      });
    });
  }
}

// Default logger instance
export const logger = new Logger();

// Middleware for Hono to add request logging
export function createLoggerMiddleware() {
  return async (c: any, next: any) => {
    const start = Date.now();
    const requestId = crypto.randomUUID();
    
    // Add request ID to context
    c.set('requestId', requestId);
    
    // Create request-specific logger
    const requestLogger = logger.child({
      requestId,
      method: c.req.method,
      path: c.req.path,
      ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
    });
    
    // Add logger to context
    c.set('logger', requestLogger);
    
    // Log request
    requestLogger.info('Request received');
    
    try {
      await next();
      
      // Log response
      const duration = Date.now() - start;
      requestLogger.info('Request completed', {
        status: c.res.status,
        duration_ms: duration,
      });
    } catch (error) {
      // Log error
      const duration = Date.now() - start;
      requestLogger.error('Request failed', error, {
        status: c.res?.status || 500,
        duration_ms: duration,
      });
      throw error;
    } finally {
      // Clear request context
      Logger.clearRequestContext(requestId);
    }
  };
}